<!doctype html>
<html lang="vi">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ESP32 License Activator</title>
  <style>
    body {
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 780px;
      margin: 32px auto;
      padding: 0 16px
    }

    h1 {
      font-size: 20px;
      margin: 0 0 12px
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0
    }

    input,
    button {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ddd
    }

    button {
      cursor: pointer
    }

    #log {
      white-space: pre-wrap;
      font-family: ui-monospace, Consolas, monospace;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 12px;
      min-height: 140px;
      background: #fafafa
    }

    .ok {
      color: #0a7a00
    }

    .err {
      color: #b00020
    }
  </style>
</head>

<body>
  <h1>ESP32 License Activator</h1>
  <div class="row">
    <button id="btnConnect">Kết nối ESP32</button>
    <button id="btnGetDid" disabled>Lấy Device ID</button>
  </div>

  <div class="row">
    <input id="inpDid" placeholder="Device ID (chỉ hiện khi bấm Get)" style="flex:1" readonly />
    <input id="inpKey" placeholder="Nhập key: MOCHI-XXXXX hoặc key trong Firebase" style="flex:1" />
  </div>

  <div class="row">
    <button id="btnActivate" disabled>Kích hoạt</button>
    <button id="btnReboot" disabled>Reboot</button>
  </div>

  <div class="row">
    <small>Endpoint ký: <code>https://license-signer.tandev.workers.dev/sign</code></small>
  </div>

  <div id="log"></div>

  <script>
    const WORKER_URL = "https://license-signer.tandev.workers.dev/sign";
    let port, reader, writer;

    // --- tiện ích ---
    const $ = s => document.querySelector(s);
    const escapeHtml = s => s.replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
    const log = (m, cls = "") => { const el = $("#log"); const t = new Date().toLocaleTimeString(); el.innerHTML += `<div class="${cls}">[${t}] ${escapeHtml(m)}</div>`; el.scrollTop = el.scrollHeight; };

    // --- hàng đợi chờ dòng phù hợp ---
    const waiters = [];
    function notifyLine(line) {
      for (let i = waiters.length - 1; i >= 0; i--) {
        const { re, resolve } = waiters[i];
        if (re.test(line)) { waiters.splice(i, 1); resolve(line); }
      }
    }
    function waitForLine(re, timeoutMs = 5000) {
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          // bỏ waiter nếu hết hạn
          const idx = waiters.findIndex(w => w.resolve === resolve);
          if (idx >= 0) waiters.splice(idx, 1);
          reject(new Error("timeout waiting for line: " + re));
        }, timeoutMs);
        waiters.push({
          re,
          resolve: (line) => { clearTimeout(timer); resolve(line); }
        });
      });
    }

    // --- read pump: đọc nền, log & phát sự kiện dòng ---
    let pumpRunning = false;
    async function startReadPump() {
      if (pumpRunning) return;
      pumpRunning = true;
      const dec = new TextDecoder();
      let buf = "";
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (!value) continue;
          buf += dec.decode(value);
          let i;
          while ((i = buf.indexOf("\n")) >= 0) {
            let line = buf.slice(0, i).replace(/\r/g, "").trim();
            buf = buf.slice(i + 1);
            if (!line) continue;
            log("<< " + line);
            notifyLine(line);
          }
        }
      } catch (e) {
        // reader closed hoặc lỗi—cứ để im, user có thể reconnect
      } finally {
        pumpRunning = false;
      }
    }

    // --- serial open / write ---
    async function openSerial() {
      if (!("serial" in navigator)) { alert("Trình duyệt không hỗ trợ Web Serial."); return; }
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });

      // USB-CDC ESP32-S3: bật DTR, tắt RTS
      try { await port.setSignals?.({ dataTerminalReady: true, requestToSend: false }); } catch { }

      reader = port.readable.getReader();
      writer = port.writable.getWriter();
      startReadPump();

      log("Đã kết nối serial.");

      // chờ ổn định một chút trước khi gửi lệnh đầu tiên
      await new Promise(r => setTimeout(r, 200));

      $("#btnGetDid").disabled = false;
      $("#btnActivate").disabled = false;
      $("#btnReboot").disabled = false;
    }

    async function sendLine(line) {
      const enc = new TextEncoder();
      await writer.write(enc.encode(line + "\r\n")); // CRLF
      log(">> " + line);
    }

    // --- nghiệp vụ ---
    async function getDid() {
      const MAX_TRY = 3;
      for (let attempt = 1; attempt <= MAX_TRY; attempt++) {
        await sendLine("GETDID");

        try {
          // nếu board vừa reset và in banner, pump sẽ log. ta chỉ chờ DID:
          const didLine = await waitForLine(/^DID:\s*[0-9A-F]{2}(?::[0-9A-F]{2}){5}$/i, 3000);
          const m = didLine.match(/^DID:\s*([0-9A-F]{2}(?::[0-9A-F]{2}){5})$/i);
          const did = m[1].toUpperCase();
          $("#inpDid").value = did;
          log("Device ID: " + did, "ok");
          return did;
        } catch (e) {
          log(`Không thấy DID (lần ${attempt})`, "err");
          // thử set lại DTR một nhịp (một số stack CDC cần tick)
          try { await port.setSignals?.({ dataTerminalReady: false }); } catch { }
          await new Promise(r => setTimeout(r, 80));
          try { await port.setSignals?.({ dataTerminalReady: true }); } catch { }
          await new Promise(r => setTimeout(r, 150));
        }
      }
      throw new Error("Không nhận được DID từ ESP32 sau nhiều lần thử");
    }

    function showPayload(license) {
      try {
        const payloadB64 = license.split(".")[0];
        const json = JSON.parse(atob(payloadB64));
        log("Payload: " + JSON.stringify(json, null, 2), "ok");
      } catch (e) { log("Decode payload lỗi: " + e, "err"); }
    }

    async function activate() {
      const deviceId = $("#inpDid").value.trim();
      const activationKey = $("#inpKey").value.trim();
      if (!deviceId) { alert("Hãy bấm 'Lấy Device ID' trước."); return; }
      if (!activationKey) { alert("Nhập activation key!"); return; }

      log("Gọi server ký...");
      const res = await fetch(WORKER_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ deviceId, activationKey })
      });
      const js = await res.json().catch(() => ({}));
      if (!res.ok) { log("Sign lỗi: " + JSON.stringify(js), "err"); return; }

      const license = js.license;
      log("Nhận license OK.");
      showPayload(license);

      await sendLine("LIC:" + license);

      // chờ [OK] hoặc [ERR:...]
      try {
        const ok = await waitForLine(/^\[(OK|ERR:.*)\]$/i, 5000);
        if (/^\[OK\]$/i.test(ok)) log("ESP32 xác nhận license.", "ok");
        else log("ESP32 từ chối license: " + ok, "err");
      } catch {
        log("Không nhận được phản hồi từ ESP32 sau khi gửi license.", "err");
      }
    }

    async function reboot() {
      await sendLine("REBOOT");
      // nếu board reset, pump sẽ thấy banner
    }

    $("#btnConnect").onclick = () => openSerial().catch(e => log(String(e), "err"));
    $("#btnGetDid").onclick = () => getDid().catch(e => log(String(e), "err"));
    $("#btnActivate").onclick = () => activate().catch(e => log(String(e), "err"));
    $("#btnReboot").onclick = () => reboot().catch(e => log(String(e), "err"));

    window.addEventListener("beforeunload", async () => {
      try { await reader?.releaseLock(); await writer?.releaseLock(); await port?.close(); } catch { }
    });
  </script>

</body>

</html>